# How to build an async .NET application with Memphis as the message broker

In this article, we will demonstrate how .NET microservices can communicate asynchronously with the help of memphis as the message broker.
Before going into depth, let’s get familiar with a few concepts to better understand the whole system.

## What is Microservices?

Microservices (or microservices architecture) is a cloud-native architectural approach in which a single application is composed of many loosely coupled and independently deployable smaller components, or services. These services typically
- have their own technology stack, inclusive of the database and data management model;
- communicate with one another over a combination of REST APIs, event streaming, and message brokers;
- and are organized by business capability, with the line separating services often referred to as a bounded context.

While much of the discussion about microservices has revolved around architectural definitions and characteristics, their value can be more commonly understood through fairly simple business and organizational benefits: 
Code can be updated more easily - new features or functionality can be added without touching the entire application 
Teams can use different stacks and different programming languages for different components.

Components can be scaled independently of one another, reducing the waste and cost associated with having to scale entire applications because a single feature might be facing too much load.

## What is a message broker?
A message broker is software that enables applications, systems, and services to communicate with each other and exchange information. The message broker does this by translating messages between formal messaging protocols. This allows interdependent services to “talk” with one another directly, even if they were written in different languages or implemented on different platforms.

Message brokers can validate, store, route, and deliver messages to the appropriate destinations. They serve as intermediaries between other applications, allowing senders to issue messages without knowing where the receivers are, whether or not they are active, or how many of them there are. This facilitates decoupling of processes and services within systems.

Message brokers enable asynchronous communications between services so that the sending service need not wait for the receiving service’s reply. This improves fault tolerance and resiliency in the systems in which they’re employed.
In addition, the use of message brokers makes it easier to scale systems since a pub/sub messaging pattern can readily support changing numbers of services. Message brokers also keep track of consumers’ states.

When talking about asynchronous messaging it refers to the type of inter-application communication that message brokers make possible.
It prevents the loss of valuable data and enables systems to continue functioning even in the face of the intermittent connectivity or latency issues common on public networks.
Asynchronous messaging guarantees that messages will be delivered once (and once only) in the correct order relative to other messages.
Message brokers in cloud architectures.

Cloud-native applications are built to take advantage of the inherent benefits of cloud computing, including flexibility, scalability, and rapid deployment. These applications are made up of small, discrete, reusable components called microservices. Each microservice is deployed and can run independently of the others. This means that any one of them can be updated, scaled, or restarted without affecting other services in the system.
Often packaged in containers, microservices work together to comprise a whole application, though each has its own stack, including a database and data model that may be different from the others.

Microservices must have a means of communicating with one another in order to operate in concert. Message brokers are one mechanism they use to create this shared communications backbone.

Memphis is a next-generation message broker. A simple, robust, and durable cloud-native message broker wrapped with an entire ecosystem that enables fast and reliable development of next-generation event-driven use cases.

## Tech stack:

- MongoDB - for persistence of product offers
- C#/NET6 - as our primary development language/framework
- Memphis - message broker for developers
- Docker - an engine where our containers will be run on

## Prerequisites:
- The Docker engine must be installed on the machine.
- If you haven’t installed it yet, you may look at Docker installation guide.
- .NET6 required in case of running applications on local machine

## Project description:

The ProductOfferManagement system uses asynchronous communication between its components. <br>
Whenever a client sends a request to create a product offer, ProductOffer.WebAPI receives the client request and publishes the message to the broker. <br>
So processing of messages is done by another component async manner. 

On the other side ProductOffer.Processor listens to the broker and processes, storing the message into the persistent database.
In this way of communication, it enables the applications functioning independently from each other, in order words achieving loose coupling.
Applications can scale out independently based on the demand.

High level system architecture and code flow:<br>
*Image #1*
<hr>

### Product Offer Management System is composed of three modules:
**ProductOffer.WebAPI**<br>
A simple Web API written in NET6, publishes messages when product offers are created and retrieves already processed offers from the database.

**ProductOffer.Processor**<br>
A background service written in NET6 - intended to listen to the messages from brokers and being responsible for processing and then storing offers in a persistence database.

**Message broker**<br>
Provides end-to-end support for in-app streaming use cases using Memphis distributed message broker.

So let’s start build an application from scratch:
<hr>

### Step 1: Create an empty solution
Create an empty solution named, ProductOfferManagement.Microservices.<br>
Using your favorite IDE, or just CLI
```
dotnet new sln --output ProductOfferManagement.Microservices
```

### Step 2: Add new project: ProductOffer.WebAPI

Add a new project: ProductOffer.WebAPI into solution.
As the name suggests, it will be WebAPI.

The final folder structure for project will be as follows:

In the ProductOffer.WebAPI project, MediatR pattern is used to segregate responsibilities of command and query operations.

The Mediator pattern is simply defining an object that encapsulates how objects interact with each other. Instead of having two or more objects take a direct dependency on each other, they instead interact with a “mediator”, who is in charge of sending those interactions to the other party:

We can see in the image above, SomeService sends a message to the Mediator, and the Mediator then invokes multiple services to handle the message. There is no direct dependency between any of the blue components

It enables “loose coupling”, as the dependency graph is minimized and therefore code is simpler and easier to test. In other words, the fewer considerations a component has, the easier it is to develop and evolve.


In our project, we have a ProductOffersController(in the place of SomeService), and multiple handlers(located under Services/Handlers).
Whenever, ProductOffersController is asked to do an operation(either command or query), it just delegates the handling of command and queries by calling Mediator.

<!-- <add code snippet from controllers> -->

From folder structure, we can see that there are predefined commands and queries(under Services/Commands, Services/Queries) and appropriate handlers for those operations(under Services/Handlers).

In the Data folder, we have classes that represent an object as an entity in the database. 
<!-- <add code snippet> -->

In the Extensions folder, there are useful extension methods to add configurations, services(as well as its dependencies) used in the projects.

In the Models folder, there are model classes that represent the outside view of entity classes.
<!-- <add code snippet> -->
In the Options folder, there are config or settings classes used in the project. 
<!-- <add code snippet> -->

In the Producer folder, there is a message producer intended to publish messages to brokers, and encapsulates broker specific details(creating connection, publishing message to station etc.).

In the Repository folder, Data Access Layer(DAL) intended classes are placed.
Whenever needed to perform operations on data entities in the database, these classes encapsulate the database layer implementations and show needed functionality.

In the Services folder, there are subfolders Commands, Queries and Handlers.
As talked before, MediatR specific classes are placed here.

And finally Program.cs where application start point.

<!-- <code snippet> -->

Dependencies used in the project:
<!-- <code snipped .csproj here> -->

BONUS: Dockerfile used to dockerize applications.
<!-- <docker file snippet>  -->

### Step 3: Add new project ProductOffer.Processor



Final folder structure for project will be as follows:


In the ProductOffer.Processor project, there is a background service that constantly consumes messages from the broker, process and store in the database.
In the BackgroundServices folder, there is ProductOfferProcessor that is a job running in the background and managed by NET runtime.
<code snippet>

In the Consumer folder, there is MessageConsumer that encapsulates the implementation details regarding broker and consuming messages.
<code snippet>


In the Data folder, there is ProductOfferDetails that represents the entity in the database.
<code snippet>

In the Repository folder, Data Access Layer(DAL) intended classes are placed.
Whenever needed to perform operations on data entities in the database, these classes encapsulate the database layer implementations and show needed functionality.
<code snippet>


And finally Program.cs where application start point.
<code snippet>

Dependencies used in the project:
<code snipped .csproj here>

BONUS: Dockerfile used to dockerize applications.
 <docker file snippet> 


Step 4: Run the applications in just 7 steps, so let's start

1. First clone the repository and navigate to project directory

git clone https://github.com/memphisdev/tutorials.git
cd ProductOfferManagement.Microservices


2. Make sure that docker and docker-compose already installed and docker is running on your machine

docker info
docker-compose –help

2.1 Run the docker-compose command to start services 

 docker-compose -f ./docker-compose.yml up -d

3. Create a station in Memphis broker. 
3.1 First, navigate to Memphis UI(http://localhost:9000), and try to login:

Hint: Get root login credentials from the environment variables section of Memphis in the docker-compose, or just inspect the container via CLI or Docker Desktop GUI.


Credentials:
 Username: root (by default)
 Password: ${ROOT_PASSWORD}

After successfully login, navigate to Stations from the left bar and create a Station with name product-offer-details leaving other options as default.


INFO: This is the name of the station in which ProductOffer.WebAPI publishes messages and ProductOffer.Processor also consumes from there. 
It is configured in the apps as environment variable(please look at ${MEMPHIS_STATION_NAME})


So till now, we’ve configured the broker, so applications will be able to work together.


4. Now, let’s get familiar with ProductOffer.WebAPI.

So, navigate to localhost:4201/swagger/index.html
GET: /api/v1/ProductOffers/list : to retrieve all product offers which was already processed  by ProductOffer.Processor in database
GET: /api/v1/ProductOffers//filter-list : to retrieve single product offer which was already processed by ProductOffer.Processor, with productId
POST: /api/v1/ProductOffers/send-product-offer : send product offer to message broker for further processing by ProductOffer.Processor

5. Let’s send a few product offers and see what’ll happen?
5.1 From swagger ui, making POST: /api/v1/ProductOffers/send-product-offer




5.2 Use the cUrl command from the terminal.

```
curl -X 'POST' \ 
  'http://localhost:4201/api/v1/ProductOffers/send-product-offer' \ 
  -H 'accept: */*' \ 
  -H 'Content-Type: application/json' \ 
  -d '{ 
  "productId": "1000001", 
  "productName": "Book", 
  "currency": "USD", 
  "productPrice": 99 
}'

```
Whenever sending new product offers, ProductOffer.WebAPI will publish ProductOfferDetails messages into the broker station, namely product-offer-details.

On the other side, our independently running background service - ProductOffer.Processor consumes the ProductOfferDetails messages, processes and stores them in the database.



6. From swagger UI,  make GET: /list from swagger ui to retrieve already processed messages.











Or just use cUrl command

```
curl -X 'GET' \ 
  'http://localhost:4201/api/v1/ProductOffers/list' \ 
  -H 'accept: text/plain'
```

7. To get more insight about Memphis, you can use UI.


So, navigate to the nice Memphis UI(localhost:9000), to see how message flow happens. 




That’s all about!

To access the source code from here.
